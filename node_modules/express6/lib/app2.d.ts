/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
/// <reference types="node" />
import http from 'http';
import { EventEmitter } from 'events';
import type { Request, Response, RequestHandler, GetSettings } from './types.js';
import { ExtensibleFunction } from './utils.js';
declare class Express extends ExtensibleFunction<RequestHandler> {
    cache: any;
    engines: any;
    settings: any;
    locals: any;
    mountpath: string;
    parent: any;
    request: Request;
    response: Response;
    router: any;
    get: GetSettings;
    constructor();
    private init;
    /** Initialize application configuration. */
    private defaultConfiguration;
    /**
     * Dispatch a req, res pair into the application. Starts pipeline processing.
     *
     * If no callback is provided, then default error handlers will respond
     * in the event of an error bubbling through the stack.
     */
    handle(req: Request, res: Response, callback: Function): void;
    /**
     * Proxy `Router#use()` to add middleware to the app router.
     * See Router#use() documentation for details.
     *
     * If the _fn_ parameter is an express app, then it will be
     * mounted at the _route_ specified.
     */
    use(path: string, ...handlers: RequestHandler[]): any;
    use(...handlers: RequestHandler[]): any;
    /**
     * Register the given template engine callback `fn`
     * as `ext`.
     *
     * By default will `require()` the engine based on the
     * file extension. For example if you try to render
     * a "foo.ejs" file Express will invoke the following internally:
     *
     *     app.engine('ejs', require('ejs').__express);
     *
     * For engines that do not provide `.__express` out of the box,
     * or if you wish to "map" a different extension to the template engine
     * you may use this method. For example mapping the EJS template engine to
     * ".html" files:
     *
     *     app.engine('html', require('ejs').renderFile);
     *
     * In this case EJS provides a `.renderFile()` method with
     * the same signature that Express expects: `(path, options, callback)`,
     * though note that it aliases this method as `ejs.__express` internally
     * so if you're using ".ejs" extensions you don't need to do anything.
     *
     * Some template engines do not follow this convention, the
     * [Consolidate.js](https://github.com/tj/consolidate.js)
     * library was created to map all of node's popular template
     * engines to follow this convention, thus allowing them to
     * work seamlessly within Express.
     */
    engine(ext: string, fn: Function): this;
    /**
     * Assign `setting` to `val`, or return `setting`'s value.
     *
     *    app.set('foo', 'bar');
     *    app.set('foo');
     *    // => "bar"
     *
     * Mounted servers inherit their parent server's settings.
     */
    set(setting: string, val?: any): this;
    /**
     * Return the app's absolute pathname
     * based on the parent(s) that have
     * mounted it.
     *
     * For example if the application was
     * mounted as "/admin", which itself
     * was mounted as "/blog" then the
     * return value would be "/blog/admin".
     */
    private path;
    /**
     * Check if `setting` is enabled (truthy).
     *
     *    app.enabled('foo')
     *    // => false
     *
     *    app.enable('foo')
     *    app.enabled('foo')
     *    // => true
     */
    enabled(setting: string): boolean;
    /**
     * Check if `setting` is disabled.
     *
     *    app.disabled('foo')
     *    // => true
     *
     *    app.enable('foo')
     *    app.disabled('foo')
     *    // => false
     */
    disabled(setting: string): boolean;
    /** Enable `setting`. */
    enable(setting: string): this;
    /** Disable `setting`. */
    disable(setting: string): this;
    /**
     * Render the given view `name` name with `options`
     * and a callback accepting an error and the
     * rendered template string.
     *
     * Example:
     *
     *    app.render('email', { name: 'Tobi' }, function(err, html){
     *      // ...
     *    })
     */
    render(name: string, options: Object | Function, callback: Function): void;
    /**
     * Listen for connections.
     *
     * A node `http.Server` is returned, with this
     * application (which is a `Function`) as its
     * callback. If you wish to create both an HTTP
     * and HTTPS server you may do so with the "http"
     * and "https" modules as shown here:
     *
     *    let http = require('http')
     *      , https = require('https')
     *      , express = require('express')
     *      , app = express();
     *
     *    http.createServer(app).listen(80);
     *    https.createServer({ ... }, app).listen(443);
     */
    listen(port?: number | undefined, listeningListener?: () => void): http.Server;
    listen(port?: number | undefined, hostname?: string | undefined, backlog?: number | undefined, listeningListener?: () => void): http.Server;
}
/** Create an express application. */
interface Express extends EventEmitter {
}
export default Express;
export { Express as app2 };
